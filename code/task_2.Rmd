---
title: "Model selection"
author: "Jaxon Stuhr"
date: "1/19/2022"
output: html_document
---

```{r setup, include=TRUE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(tidyverse)
library(here)
library(equatiomatic)
library(AICcmodavg)
```

```{r}
# read in data
samples = read_csv(here("data", "calcofi_seawater_samples.csv"))
```

```{r}
# build two models, O2 saturation as func of 1) water temp, salinity, phosphate concentration and 2) water temp, salinity, phosphate concentration, depth
mdl1 = lm(o2sat ~ t_deg_c + salinity + po4u_m, 
          data = samples)
mdl2 = lm(o2sat ~ t_deg_c + salinity + po4u_m + depth_m, 
          data = samples)
```

```{r}
# AIC analysis
aictab(list(mdl1, mdl2))
```

Model 2, which considers O2 saturation as a function of water temp, salinity, phosphate concentration, and depth, outperforms Model 1 which does not include depth. It's AICc score is > 2 points better, implying a significant improvement. 

```{r}
# initialize "folds" and data frames for cross validation analysis
folds = 10
fold_vec = rep(1:folds, length.out = nrow(samples))
table(fold_vec)

set.seed(61) # fix the random numbers for repeatability

samples_fold = samples %>% 
  mutate(group = sample(fold_vec, size = n(), replace = FALSE))
# first fold
test_df = samples_fold %>% 
  filter(group == 1)
train_df = samples_fold %>% 
  filter(group != 1)
```

```{r root mean square error function}
# build calc_rmse, a function to calculate the root mean square error
calc_rmse = function(x, y) {
  rmse_result = (x-y)^2 %>% mean() %>% sqrt()
  return(rmse_result)
}
```

```{r}
# build formulas for training
f1 = o2sat ~ t_deg_c + salinity + po4u_m
f2 = o2sat ~ t_deg_c + salinity + po4u_m + depth_m
```



